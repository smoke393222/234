"""QR code and VLESS link generation utilities."""

from io import BytesIO
from urllib.parse import urlencode
from typing import Optional
import qrcode

from core.config import settings
from core.logger import log


def generate_vless_link(
    uuid: str, 
    email: str, 
    server: Optional[str] = None,
    port: Optional[int] = None,
    sni: Optional[str] = None
) -> str:
    """
    Generate VLESS connection link.
    
    Args:
        uuid: Client UUID
        email: Client email (used as remark)
        server: Server address (defaults to settings)
        port: Server port (defaults to settings)
        sni: SNI (defaults to settings)
    
    Returns:
        VLESS connection string
    """
    # Use provided values or defaults from settings
    server = server or settings.VLESS_SERVER
    port = port or settings.VLESS_PORT
    sni = sni or settings.VLESS_SNI
    
    # Build query parameters
    params = {
        "type": settings.VLESS_TYPE,
        "security": settings.VLESS_SECURITY,
        "sni": sni
    }
    
    # Build VLESS link
    # Format: vless://uuid@server:port?params#remark
    link = f"vless://{uuid}@{server}:{port}?{urlencode(params)}#{email}"
    
    log.info(f"Generated VLESS link for {email}")
    return link


def generate_qr_code(data: str) -> BytesIO:
    """
    Generate QR code image from data string.
    
    Args:
        data: String data to encode (e.g., VLESS link)
    
    Returns:
        BytesIO object containing PNG image
    """
    # Create QR code
    qr = qrcode.QRCode(
        version=1,
        error_correction=qrcode.constants.ERROR_CORRECT_L,
        box_size=10,
        border=4,
    )
    qr.add_data(data)
    qr.make(fit=True)
    
    # Create image
    img = qr.make_image(fill_color="black", back_color="white")
    
    # Save to BytesIO
    bio = BytesIO()
    img.save(bio, format='PNG')
    bio.seek(0)
    
    log.info("Generated QR code")
    return bio


def generate_vless_qr(
    uuid: str, 
    email: str,
    server: Optional[str] = None,
    port: Optional[int] = None,
    sni: Optional[str] = None
) -> tuple[str, BytesIO]:
    """
    Generate both VLESS link and QR code.
    
    Args:
        uuid: Client UUID
        email: Client email
        server: Server address (optional)
        port: Server port (optional)
        sni: SNI (optional)
    
    Returns:
        Tuple of (vless_link, qr_code_image)
    """
    link = generate_vless_link(uuid, email, server, port, sni)
    qr_image = generate_qr_code(link)
    return link, qr_image

"""Utils package for helper functions."""

"""Data formatting utilities."""

from datetime import datetime


def format_traffic_gb(bytes_value: int) -> str:
    """
    Convert bytes to gigabytes with 2 decimal places.
    
    Args:
        bytes_value: Traffic in bytes
    
    Returns:
        Formatted string like "1.23 ГБ"
    """
    gb = bytes_value / (1024 ** 3)
    return f"{gb:.2f} ГБ"


def format_traffic_mb(bytes_value: int) -> str:
    """
    Convert bytes to megabytes with 2 decimal places.
    
    Args:
        bytes_value: Traffic in bytes
    
    Returns:
        Formatted string like "123.45 МБ"
    """
    mb = bytes_value / (1024 ** 2)
    return f"{mb:.2f} МБ"


def format_datetime(dt: datetime) -> str:
    """
    Format datetime to readable string.
    
    Args:
        dt: Datetime object
    
    Returns:
        Formatted string like "21.01.2026 15:30"
    """
    return dt.strftime("%d.%m.%Y %H:%M")


def format_date(dt: datetime) -> str:
    """
    Format datetime to date string.
    
    Args:
        dt: Datetime object
    
    Returns:
        Formatted string like "21.01.2026"
    """
    return dt.strftime("%d.%m.%Y")


def format_status(is_active: bool) -> str:
    """
    Format active status to emoji and text.
    
    Args:
        is_active: Boolean status
    
    Returns:
        Formatted string with emoji
    """
    return "✅ Активен" if is_active else "❌ Деактивирован"


def format_approval_status(is_approved: bool) -> str:
    """
    Format approval status to emoji and text.
    
    Args:
        is_approved: Boolean approval status
    
    Returns:
        Formatted string with emoji
    """
    return "✅ Одобрен" if is_approved else "⏳ Ожидает одобрения"
